## Лабораторная 8‑10. Теоретические сведения

### 1. Сетевая модель и протоколы
- **Модель TCP/IP**: сервер использует TCP (ориентированный на соединение, обеспечивает доставку и порядок), UDP применён для широковещательного поиска сервера по позывному.  
- **Сокеты**: `socket`, `bind`, `listen`, `accept` на стороне сервера; `connect` на стороне клиента. Неблокирующий режим (`ioctlsocket` + `FIONBIO`) позволяет не зависать на ожидании данных.

### 2. Winsock2 и управление ошибками
- Инициализация через `WSAStartup`, завершение через `WSACleanup`.  
- Все операции возвращают код ошибки `SOCKET_ERROR`; детализация через `WSAGetLastError`. В коде предусмотрена функция `SetErrorMsgText`, преобразующая значения WSA‑кодекса в человекочитаемые строки.

### 3. Архитектура сервера
- **ConcurrentServer** — главный процесс, который:  
  - принимает подключения и формирует записи `Contact`;  
  - запускает обслуживающие потоки из DLL;  
  - ведёт статистику (`Accept`, `Fail`, `Finished`, `ClientServiceNumber`).  
- Используется список `Contacts` с синхронизацией через критические секции (при необходимости). Каждому подключению соответствует структура `Contact` с сокетом, состояниями и таймером.

### 4. Динамическая загрузка сервисов
- Службы (`RandServer`, `TimeServer`, `EchoServer`) располагаются в DLL `Service_Library`.  
- Экспортируются функции, отвечающие за выделенную бизнес‑логику. При старте сервера DLL подгружается через `LoadLibrary`, а указатели на функции сохраняются в `ts2`, `ts3`. Это иллюстрирует модульность: можно заменять/добавлять сервисы без перекомпиляции сервера.

### 5. Потоки и асинхронные процедуры
- Каждый сервис запускается в отдельном потоке (`CreateThread`).  
- Состояния потоков отслеживаются через `Contact::sthread` (`WORK`, `FINISH`, `ABORT`, `TIMEOUT`).  
- Для уведомления основного потока используются **асинхронные процедуры завершения** (`QueueUserAPC`):  
  - `ASStartMessage` — сообщает о начале обслуживания;  
  - `ASFinishMessage` — фиксирует штатное завершение;  
  - `ASWTimer` — вызывается таймером при истечении времени.

### 6. Таймеры и контроль времени
- Для каждого клиента создаётся waitable‑таймер (`CreateWaitableTimer`).  
- `ASWTimer` помечает `TimerOff = true` и переводит поток в состояние `TIMEOUT`.  
- После истечения тайм‑аута сервис посылает клиенту системное сообщение `Close: timeout;` и закрывает сокет.  
- Знание работы с APC и waitable‑таймерами важно при защите: нужно объяснить, что таймер срабатывает в контексте потока, на чьей очереди стоит APC.

### 7. Клиентская логика
- Клиент умеет подключаться по имени или по позывному, используя UDP‑рассылку (SO_BROADCAST).  
- После установления TCP‑соединения клиент выбирает сервис, отправляет команду и получает ответы. В текущей версии каждое пользовательское сообщение даёт строго один отклик, что демонстрирует управление отправкой/приёмом со стороны клиента.

### 8. Удалённая консоль
- `RemoteConsole` взаимодействует с сервером для управления очередью клиентов: отправляет команды `START`, `STOP`, `STATISTICS`, `SHUTDOWN`.  
- Понимание командного интерфейса позволяет объяснить, как организован контроль работы сервера и сбор статистики.

### 9. Обработка исключительных ситуаций
- Ошибки при сетевых вызовах приводят к исключениям, которые перехватываются и фиксируются.  
- При аварии поток помечается как `ABORT`, таймеры отменяются.  
- Клиент интерпретирует системные сообщения (`Close: finish;`, `Close: timeout;`, `Close: Abort;`) и корректно закрывает соединение.

### 10. Возможные вопросы на защите
1. Чем TCP отличается от UDP и почему выбраны оба?  
2. Как реализована динамическая загрузка сервисов и зачем она нужна?  
3. Что такое APC и чем отличается от обычного callback?  
4. Как работает таймер: в каком потоке выполняется `ASWTimer` и что произойдёт, если поток занят?  
5. Как клиент обнаруживает сервер по позывному?  
6. Что произойдёт при выключении сервера во время активных клиентов?  
7. Как обеспечивается безопасность при многопоточности (critical section, атомарные счётчики)?  
8. Какие системные сообщения отправляются клиенту и в каких случаях?

### 11. Рекомендации по подготовке
- Уметь показать последовательность вызовов при установлении соединения.  
- Быть готовым объяснить каждое состояние `Contact` и `sthread`.  
- Иметь представление о структуре DLL (заголовочные файлы, экспортируемые функции).  
- Знать местоположение основных участков кода: `Service_Library/*.h`, `ConcurrentServer/*.cpp`, `Client/Client.cpp`.





