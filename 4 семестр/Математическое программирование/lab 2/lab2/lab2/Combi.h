// Combi.h      
#pragma once 
namespace combi
{
    struct subset
    {
        short  n,                 // Количество элементов в множестве (должно быть меньше 64)
            sn,                   // Количество элементов в текущем подмножестве
            * sset;               // Массив элементов текущего подмножества 
        unsigned __int64 mask;    // Битовая маска для подмножества 
        subset(short n = 1);      // Конструктор (количество элементов в множестве) 
        short getfirst();         // Получить первое подмножество из битовой маски    
        short getnext();          // Получить следующее подмножество в последовательности 
        short ntx(short i);       // Получить i-й элемент текущего подмножества 
        unsigned __int64 count(); // Получить общее количество возможных подмножеств 
        void reset();             // Сбросить подмножество, инициализировать маску 
    };

    struct xcombination                 // Генератор комбинаций 
    {
        short  n,                        // Количество элементов в множестве  
            m,                           // Количество элементов в комбинации 

            * sset;            	         // Массив элементов текущей комбинации  
        xcombination(
            short n = 1,                 // Количество элементов в множестве  
            short m = 1                  // Количество элементов в комбинации
        );
        void reset();                    // Сбросить комбинацию, инициализировать последовательность 
        short getfirst();                // Получить первую комбинацию в последовательности    
        short getnext();                 // Получить следующую комбинацию в последовательности  
        short ntx(short i);              // Получить i-й элемент текущей комбинации  
        unsigned __int64 nc;             // Текущий индекс комбинации (0, ..., count()-1)   
        unsigned __int64 count() const;  // Получить общее количество возможных комбинаций      
    };

    struct permutation    // Генератор перестановок     
    {
        const static bool L = true;  // Направление влево 
        const static bool R = false; // Направление вправо   

        short  n,              // Количество элементов в множестве 
            * sset;           // Массив элементов текущей перестановки
        bool* dart;           // Массив направлений (L - влево, R - вправо) 
        permutation(short n = 1); // Конструктор (количество элементов в множестве) 

        void reset();                // Сбросить перестановку, инициализировать последовательность 

        __int64 getfirst();          // Получить первую перестановку в последовательности    
        __int64 getnext();           // Получить следующую перестановку в последовательности  

        short ntx(short i);          // Получить i-й элемент текущей перестановки 
        unsigned __int64 np;         // Текущий индекс перестановки (0, ..., count()-1) 

        unsigned __int64 count() const;  // Получить общее количество возможных перестановок    
    };

};