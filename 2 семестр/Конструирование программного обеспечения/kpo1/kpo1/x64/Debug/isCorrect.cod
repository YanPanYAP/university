; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33130.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__6628E330_concurrencysal@h DB 01H
__DD735C24_sal@h DB 01H
__95D07812_vadefs@h DB 01H
__2C966F75_vcruntime@h DB 01H
__C84B2A68_xkeycheck@h DB 01H
__E4981F91_yvals_core@h DB 01H
__FFDAFD70___msvc_sanitizer_annotate_container@hpp DB 01H
__1B0272D9_corecrt@h DB 01H
__50BF2FAA_vcruntime_new@h DB 01H
__973DD6D2_vcruntime_new_debug@h DB 01H
__935DC21B_crtdbg@h DB 01H
__EA84BEDA_crtdefs@h DB 01H
__7A2C09FE_use_ansi@h DB 01H
__B806B4B7_yvals@h DB 01H
__44420885_corecrt_stdio_config@h DB 01H
__AB601D8D_corecrt_wstdio@h DB 01H
__C1EC35D3_stdio@h DB 01H
__099E6B1A_cstdio DB 01H
__61CC25A1_errno@h DB 01H
__21B98AC3_vcruntime_string@h DB 01H
__E4C945B4_corecrt_memcpy_s@h DB 01H
__8EAFF484_corecrt_memory@h DB 01H
__6490AEC5_corecrt_wstring@h DB 01H
__E8295E1E_string@h DB 01H
__42D4AAE8_cstring DB 01H
__EF1F6BBA_corecrt_wconio@h DB 01H
__74484FB3_corecrt_wctype@h DB 01H
__3D1D430C_corecrt_wdirect@h DB 01H
__8ECB7138_corecrt_share@h DB 01H
__DB7FEBA6_corecrt_wio@h DB 01H
__9A9F0068_corecrt_wprocess@h DB 01H
__E2E33A61_corecrt_wstdlib@h DB 01H
__369A9BC3_corecrt_wtime@h DB 01H
__CE789B9D_types@h DB 01H
__9901C817_stat@h DB 01H
__3FCAD62E_wchar@h DB 01H
__9315BD49_cwchar DB 01H
__81223BB7_xtr1common DB 01H
__D0D5387F_iosfwd DB 01H
__EDDD1674_stdint@h DB 01H
__B318E375_cstdint DB 01H
__BB16330F_corecrt_math@h DB 01H
__3BF2A406_math@h DB 01H
__45DED006_corecrt_malloc@h DB 01H
__13F5961F_stddef@h DB 01H
__FD6DBD68_corecrt_search@h DB 01H
__53AB384B_limits@h DB 01H
__6E5ACABA_stdlib@h DB 01H
__0E460208_cstdlib DB 01H
__B9985323_float@h DB 01H
__7ADAA09D_cfloat DB 01H
__8AA920FA_climits DB 01H
__2FEC17FD_intrin0@inl@h DB 01H
__F3A907D1_intrin0@h DB 01H
__1C3CEDF9_limits DB 01H
__AB8DD8A5_cstddef DB 01H
__86E2ECA3_type_traits DB 01H
__FA77ED4C_malloc@h DB 01H
__89766DA4_corecrt_terminate@h DB 01H
__597317E9_eh@h DB 01H
__9FD3D380_vcruntime_exception@h DB 01H
__22DBD04C_exception DB 01H
__6B6686E8_new DB 01H
__28D75C9A_xatomic@h DB 01H
__7CEE9503_initializer_list DB 01H
__394B8783_utility DB 01H
__6CD66C6A___msvc_iter_core@hpp DB 01H
__81056E89_xutility DB 01H
__53DEE440_xmemory DB 01H
__270D62DC_xstring DB 01H
__1EC467ED_ctype@h DB 01H
__06558CBD_cctype DB 01H
__D44167EB_string DB 01H
__BFC95293_cmath DB 01H
__90A9D9C9_iterator DB 01H
__F7972D0B_share@h DB 01H
__C9486F03___msvc_system_error_abi@hpp DB 01H
__94BF1FE1_cerrno DB 01H
__AB95EA11_stdexcept DB 01H
__A700C1C1_xcall_once@h DB 01H
__1093A1B8_xerrc@h DB 01H
__0A9237D2_time@h DB 01H
__797ACE9B_ctime DB 01H
__37C18DC8_xtimec@h DB 01H
__1B623E4D_xthreads@h DB 01H
__7709B13B_atomic DB 01H
__185DD3E1_system_error DB 01H
__78388AF5_vcruntime_typeinfo@h DB 01H
__F1DA9D90_typeinfo DB 01H
__A092E177_memory DB 01H
__8CD7B678_xfacet DB 01H
__8B91FF0A___msvc_xlocinfo_types@hpp DB 01H
__791C33B7_locale@h DB 01H
__9DEADED9_clocale DB 01H
__EE537E58_xlocinfo DB 01H
__F83316ED_xlocale DB 01H
__D7B6094B_xiosbase DB 01H
__A93552AD_streambuf DB 01H
__66B470FA_xlocnum DB 01H
__93ABBCFE_ios DB 01H
__EB23CC29_ostream DB 01H
__88F3F913_istream DB 01H
__E37C1496_iostream DB 01H
__BD6F46B1_stdafx@h DB 01H
__FFA5C47D_isCorrect@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPEAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_K@Z		; __empty_global_delete
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base12@std@@QEAAXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?isCorrect@@YA_NHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; isCorrect
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z	; std::_Deallocate<16,0>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	__JustMyCode_Default
PUBLIC	?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GC@MFPFMMDA@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1ME@HBHJKKLJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ ; `string'
PUBLIC	??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ ; `string'
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	__imp__invalid_parameter:PROC
EXTRN	__imp__CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QEAA@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QEAA@XZ:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN21
	DD	imagerel $LN21+453
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+134
	DD	imagerel $unwind$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+151
	DD	imagerel $unwind$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN13
	DD	imagerel $LN13+209
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+214
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+215
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isCorrect@@YA_NHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN12
	DD	imagerel $LN12+352
	DD	imagerel $unwind$?isCorrect@@YA_NHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+98
	DD	imagerel $unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
CONST	SEGMENT
??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ DB '"'
	DB	00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p', 00H
	DB	'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'p', 00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'b', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'o', 00H, 'f'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'z', 00H
	DB	'e', 00H, 'r', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
CONST	SEGMENT
??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ DB 'null pointe'
	DB	'r cannot point to a block of non-zero size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1ME@HBHJKKLJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1ME@HBHJKKLJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H
	DB	'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M'
	DB	00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H
	DB	'.', 00H, '3', 00H, '8', 00H, '.', 00H, '3', 00H, '3', 00H, '1'
	DB	00H, '3', 00H, '0', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm'
	DB	00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@MFPFMMDA@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@MFPFMMDA@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'38.33130\include\xmemory', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA DD 09aH ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD 025051819H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD 025051819H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isCorrect@@YA_NHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 025052001H
	DD	011b2320H
	DD	070140021H
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 025051301H
	DD	010e2313H
	DD	07007002dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	0bdH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 025053d19H
	DD	010e2313H
	DD	070070029H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0138H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ$rtcName$0 DB 024H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	DB	053H
	DB	034H
	DB	00H
	ORG $+12
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ$rtcVarDesc DD 044H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	DD	01H
	DQ	FLAT:??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ$rtcName$0
	ORG $+48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ$rtcFrameData DD 01H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	DD	00H
	DQ	FLAT:??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DB 060H
	DD	imagerel $ip2state$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD 025051d19H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 035051d01H
	DD	0118331dH
	DD	07011001fH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	07eH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ DD 025053d19H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcName$0 DB 05fH ; std::_Container_base12::_Orphan_all_locked_v3
	DB	04cH
	DB	06fH
	DB	063H
	DB	06bH
	DB	00H
	ORG $+10
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcVarDesc DD 024H ; std::_Container_base12::_Orphan_all_locked_v3
	DD	04H
	DQ	FLAT:?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcName$0
	ORG $+48
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcFrameData DD 01H ; std::_Container_base12::_Orphan_all_locked_v3
	DD	00H
	DQ	FLAT:?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 035051801H
	DD	01133318H
	DD	0700c002fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAX_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAX@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	c2 00 00	 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
_Al$ = 224
_Ptr$ = 232
_Count$ = 240
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 705  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__53DEE440_xmemory
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 706  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 707  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 708  :         if (_STD is_constant_evaluated()) {
; 709  :             _Al.deallocate(_Ptr, _Count);
; 710  :         } else
; 711  : #endif // _HAS_CXX20
; 712  :         {
; 713  :             (void) _Al;
; 714  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00029	48 6b 85 f0 00
	00 00 10	 imul	 rax, QWORD PTR _Count$[rbp], 16
  00031	48 8b d0	 mov	 rdx, rax
  00034	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR _Ptr$[rbp]
  0003b	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 715  :         }
; 716  :     }

  00040	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00047	5f		 pop	 rdi
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$ = 224
_Ptr$ = 232
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1123 : _CONSTEXPR20 void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__53DEE440_xmemory
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1124 :     // deallocate a plain pointer using an allocator
; 1125 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1126 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1127 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

  00024	41 b8 01 00 00
	00		 mov	 r8d, 1
  0002a	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR _Ptr$[rbp]
  00031	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR _Al$[rbp]
  00038	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
  0003d	90		 npad	 1

; 1128 :     } else {
; 1129 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1130 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1131 :     }
; 1132 : }

  0003e	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00045	5f		 pop	 rdi
  00046	5d		 pop	 rbp
  00047	c3		 ret	 0
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 224
_Bytes$ = 232
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16,0>, COMDAT

; 251  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__53DEE440_xmemory
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 252  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 253  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 254  :     if (_STD is_constant_evaluated()) {
; 255  :         ::operator delete(_Ptr);
; 256  :     } else
; 257  : #endif // _HAS_CXX20
; 258  :     {
; 259  : #if defined(_M_IX86) || defined(_M_X64)
; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00024	48 81 bd e8 00
	00 00 00 10 00
	00		 cmp	 QWORD PTR _Bytes$[rbp], 4096 ; 00001000H
  0002f	72 13		 jb	 SHORT $LN2@Deallocate

; 261  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  00031	48 8d 95 e8 00
	00 00		 lea	 rdx, QWORD PTR _Bytes$[rbp]
  00038	48 8d 8d e0 00
	00 00		 lea	 rcx, QWORD PTR _Ptr$[rbp]
  0003f	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
$LN2@Deallocate:

; 262  :         }
; 263  : #endif // defined(_M_IX86) || defined(_M_X64)
; 264  :         ::operator delete(_Ptr, _Bytes);

  00044	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR _Bytes$[rbp]
  0004b	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR _Ptr$[rbp]
  00052	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00057	90		 npad	 1

; 265  :     }
; 266  : }

  00058	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0005f	5f		 pop	 rdi
  00060	5d		 pop	 rbp
  00061	c3		 ret	 0
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 224
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 303  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__53DEE440_xmemory
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 304  :     if constexpr (is_array_v<_Ty>) {
; 305  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 306  :     } else {
; 307  :         _Obj.~_Ty();
; 308  :     }
; 309  : }

  0001f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00026	5f		 pop	 rdi
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT

; 966  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__53DEE440_xmemory
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00032	5f		 pop	 rdi
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$ = 224
_Ptr$ = 232
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1135 : _CONSTEXPR20 void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__53DEE440_xmemory
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1136 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1137 :     using _Ty = typename _Alloc::value_type;
; 1138 :     _Ptr->~_Ty();
; 1139 :     _Deallocate_plain(_Al, _Ptr);

  00024	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR _Ptr$[rbp]
  0002b	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR _Al$[rbp]
  00032	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >

; 1140 : }

  00037	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0003e	5f		 pop	 rdi
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File \\Mac\Home\Documents\fit\kpo\kpo1\kpo1\isCorrect.cpp
;	COMDAT ?isCorrect@@YA_NHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 196
tv92 = 212
day$ = 256
month$ = 264
year$ = 272
date$ = 280
?isCorrect@@YA_NHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; isCorrect, COMDAT

; 3    : bool isCorrect(int day, int month, int year, string date) {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	55		 push	 rbp
  00013	57		 push	 rdi
  00014	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0001b	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__FFA5C47D_isCorrect@cpp
  00027	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4    : 	return (((year % 4 == 0 && month == 2 && day < 30) || (month == 2 && day < 29) || (month == 4 || month == 6 || month == 9 || month == 11 && day < 31) || (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12 && day < 32)) && month < 13 && 0 < year && year <= 9999 && 0 < day && day < 32 && date.length() == 8);

  0002c	8b 85 10 01 00
	00		 mov	 eax, DWORD PTR year$[rbp]
  00032	99		 cdq
  00033	83 e2 03	 and	 edx, 3
  00036	03 c2		 add	 eax, edx
  00038	83 e0 03	 and	 eax, 3
  0003b	2b c2		 sub	 eax, edx
  0003d	85 c0		 test	 eax, eax
  0003f	75 16		 jne	 SHORT $LN3@isCorrect
  00041	83 bd 08 01 00
	00 02		 cmp	 DWORD PTR month$[rbp], 2
  00048	75 0d		 jne	 SHORT $LN3@isCorrect
  0004a	83 bd 00 01 00
	00 1e		 cmp	 DWORD PTR day$[rbp], 30
  00051	0f 8c 87 00 00
	00		 jl	 $LN6@isCorrect
$LN3@isCorrect:
  00057	83 bd 08 01 00
	00 02		 cmp	 DWORD PTR month$[rbp], 2
  0005e	75 09		 jne	 SHORT $LN4@isCorrect
  00060	83 bd 00 01 00
	00 1d		 cmp	 DWORD PTR day$[rbp], 29
  00067	7c 75		 jl	 SHORT $LN6@isCorrect
$LN4@isCorrect:
  00069	83 bd 08 01 00
	00 04		 cmp	 DWORD PTR month$[rbp], 4
  00070	74 6c		 je	 SHORT $LN6@isCorrect
  00072	83 bd 08 01 00
	00 06		 cmp	 DWORD PTR month$[rbp], 6
  00079	74 63		 je	 SHORT $LN6@isCorrect
  0007b	83 bd 08 01 00
	00 09		 cmp	 DWORD PTR month$[rbp], 9
  00082	74 5a		 je	 SHORT $LN6@isCorrect
  00084	83 bd 08 01 00
	00 0b		 cmp	 DWORD PTR month$[rbp], 11
  0008b	75 09		 jne	 SHORT $LN7@isCorrect
  0008d	83 bd 00 01 00
	00 1f		 cmp	 DWORD PTR day$[rbp], 31
  00094	7c 48		 jl	 SHORT $LN6@isCorrect
$LN7@isCorrect:
  00096	83 bd 08 01 00
	00 01		 cmp	 DWORD PTR month$[rbp], 1
  0009d	74 3f		 je	 SHORT $LN6@isCorrect
  0009f	83 bd 08 01 00
	00 03		 cmp	 DWORD PTR month$[rbp], 3
  000a6	74 36		 je	 SHORT $LN6@isCorrect
  000a8	83 bd 08 01 00
	00 05		 cmp	 DWORD PTR month$[rbp], 5
  000af	74 2d		 je	 SHORT $LN6@isCorrect
  000b1	83 bd 08 01 00
	00 07		 cmp	 DWORD PTR month$[rbp], 7
  000b8	74 24		 je	 SHORT $LN6@isCorrect
  000ba	83 bd 08 01 00
	00 08		 cmp	 DWORD PTR month$[rbp], 8
  000c1	74 1b		 je	 SHORT $LN6@isCorrect
  000c3	83 bd 08 01 00
	00 0a		 cmp	 DWORD PTR month$[rbp], 10
  000ca	74 12		 je	 SHORT $LN6@isCorrect
  000cc	83 bd 08 01 00
	00 0c		 cmp	 DWORD PTR month$[rbp], 12
  000d3	75 57		 jne	 SHORT $LN9@isCorrect
  000d5	83 bd 00 01 00
	00 20		 cmp	 DWORD PTR day$[rbp], 32	; 00000020H
  000dc	7d 4e		 jge	 SHORT $LN9@isCorrect
$LN6@isCorrect:
  000de	83 bd 08 01 00
	00 0d		 cmp	 DWORD PTR month$[rbp], 13
  000e5	7d 45		 jge	 SHORT $LN9@isCorrect
  000e7	83 bd 10 01 00
	00 00		 cmp	 DWORD PTR year$[rbp], 0
  000ee	7e 3c		 jle	 SHORT $LN9@isCorrect
  000f0	81 bd 10 01 00
	00 0f 27 00 00	 cmp	 DWORD PTR year$[rbp], 9999 ; 0000270fH
  000fa	7f 30		 jg	 SHORT $LN9@isCorrect
  000fc	83 bd 00 01 00
	00 00		 cmp	 DWORD PTR day$[rbp], 0
  00103	7e 27		 jle	 SHORT $LN9@isCorrect
  00105	83 bd 00 01 00
	00 20		 cmp	 DWORD PTR day$[rbp], 32	; 00000020H
  0010c	7d 1e		 jge	 SHORT $LN9@isCorrect
  0010e	48 8b 8d 18 01
	00 00		 mov	 rcx, QWORD PTR date$[rbp]
  00115	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  0011a	48 83 f8 08	 cmp	 rax, 8
  0011e	75 0c		 jne	 SHORT $LN9@isCorrect
  00120	c7 85 d4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv92[rbp], 1
  0012a	eb 0a		 jmp	 SHORT $LN10@isCorrect
$LN9@isCorrect:
  0012c	c7 85 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv92[rbp], 0
$LN10@isCorrect:
  00136	0f b6 85 d4 00
	00 00		 movzx	 eax, BYTE PTR tv92[rbp]
  0013d	88 85 c4 00 00
	00		 mov	 BYTE PTR $T1[rbp], al
  00143	48 8b 8d 18 01
	00 00		 mov	 rcx, QWORD PTR date$[rbp]
  0014a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0014f	0f b6 85 c4 00
	00 00		 movzx	 eax, BYTE PTR $T1[rbp]

; 5    : }

  00156	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0015d	5f		 pop	 rdi
  0015e	5d		 pop	 rbp
  0015f	c3		 ret	 0
?isCorrect@@YA_NHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; isCorrect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0001a	48 8b c8	 mov	 rcx, rax
  0001d	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
  00022	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00029	5f		 pop	 rdi
  0002a	5d		 pop	 rbp
  0002b	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1526 :     constexpr _Ty1& _Get_first() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__53DEE440_xmemory
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1527 :         return *this;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]

; 1528 :     }

  00026	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0002d	5f		 pop	 rdi
  0002e	5d		 pop	 rbp
  0002f	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4865 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__270D62DC_xstring
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4866 :         return _Mypair._Get_first();

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	48 8b c8	 mov	 rcx, rax
  00029	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4867 :     }

  0002e	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00035	5f		 pop	 rdi
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_My_data$ = 8
_Ptr$1 = 40
_Al$2 = 72
$T3 = 292
this$ = 352
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 4837 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__270D62DC_xstring
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4838 :         auto& _My_data = _Mypair._Myval2;

  0001f	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	48 89 45 08	 mov	 QWORD PTR _My_data$[rbp], rax

; 4839 :         _My_data._Orphan_all();

  0002a	48 8b 4d 08	 mov	 rcx, QWORD PTR _My_data$[rbp]
  0002e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 4840 :         if (_My_data._Large_mode_engaged()) {

  00033	48 8b 4d 08	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00037	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
  0003c	0f b6 c0	 movzx	 eax, al
  0003f	85 c0		 test	 eax, eax
  00041	74 4a		 je	 SHORT $LN2@Tidy_deall

; 4841 :             _ASAN_STRING_REMOVE(*this);
; 4842 :             const pointer _Ptr = _My_data._Bx._Ptr;

  00043	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  00047	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004b	48 89 45 28	 mov	 QWORD PTR _Ptr$1[rbp], rax

; 4843 :             auto& _Al          = _Getal();

  0004f	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00056	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0005b	48 89 45 48	 mov	 QWORD PTR _Al$2[rbp], rax

; 4844 :             _Destroy_in_place(_My_data._Bx._Ptr);

  0005f	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  00063	48 83 c0 08	 add	 rax, 8
  00067	48 8b c8	 mov	 rcx, rax
  0006a	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ; std::_Destroy_in_place<char *>

; 4845 :             _My_data._Activate_SSO_buffer();

  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00073	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 4846 :             _Deallocate_for_capacity(_Al, _Ptr, _My_data._Myres);

  00078	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  0007c	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  00080	48 8b 55 28	 mov	 rdx, QWORD PTR _Ptr$1[rbp]
  00084	48 8b 4d 48	 mov	 rcx, QWORD PTR _Al$2[rbp]
  00088	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
$LN2@Tidy_deall:

; 4847 :         }
; 4848 : 
; 4849 :         _My_data._Mysize = 0;

  0008d	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  00091	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 4850 :         _My_data._Myres  = _Small_string_capacity;

  00099	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  0009d	48 c7 40 20 0f
	00 00 00	 mov	 QWORD PTR [rax+32], 15

; 4851 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4852 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000a5	c6 85 24 01 00
	00 00		 mov	 BYTE PTR $T3[rbp], 0
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 00	 imul	 rax, rax, 0
  000b5	48 8b 4d 08	 mov	 rcx, QWORD PTR _My_data$[rbp]
  000b9	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  000be	48 8d 95 24 01
	00 00		 lea	 rdx, QWORD PTR $T3[rbp]
  000c5	48 8b c8	 mov	 rcx, rax
  000c8	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4853 :     }

  000cd	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  000d4	5f		 pop	 rdi
  000d5	5d		 pop	 rbp
  000d6	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 224
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT

; 4118 :     _NODISCARD _CONSTEXPR20 size_type length() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__270D62DC_xstring
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4119 :         return _Mypair._Myval2._Mysize;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]

; 4120 :     }

  0002a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00031	5f		 pop	 rdi
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
_Alproxy$ = 8
$S4$ = 36
_To_delete$ = 72
__$ArrayPad$ = 280
this$ = 320
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3138 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00018	b9 1a 00 00 00	 mov	 ecx, 26
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR [rsp+360]
  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00033	48 33 c5	 xor	 rax, rbp
  00036	48 89 85 18 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__270D62DC_xstring
  00044	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3139 :         _Tidy_deallocate();

  00049	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00050	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 3140 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3141 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00055	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0005c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00061	48 8b d0	 mov	 rdx, rax
  00064	48 8d 4d 24	 lea	 rcx, QWORD PTR $S4$[rbp]
  00068	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0006d	48 8d 45 24	 lea	 rax, QWORD PTR $S4$[rbp]
  00071	48 89 45 08	 mov	 QWORD PTR _Alproxy$[rbp], rax

; 3142 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;

  00075	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0007c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007f	48 89 45 48	 mov	 QWORD PTR _To_delete$[rbp], rax

; 3143 :         _Mypair._Myval2._Myproxy = nullptr;

  00083	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 3144 :         _Delete_plain_internal(_Alproxy, _To_delete);

  00091	48 8b 55 48	 mov	 rdx, QWORD PTR _To_delete$[rbp]
  00095	48 8b 4d 08	 mov	 rcx, QWORD PTR _Alproxy$[rbp]
  00099	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >

; 3145 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3146 :     }

  0009e	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a5	48 8b c8	 mov	 rcx, rax
  000a8	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  000ad	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ$rtcFrameData
  000b8	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000bd	48 8b 8d 18 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000c4	48 33 cd	 xor	 rcx, rbp
  000c7	e8 00 00 00 00	 call	 __security_check_cookie
  000cc	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  000d3	5f		 pop	 rdi
  000d4	5d		 pop	 rbp
  000d5	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
_TEXT	SEGMENT
_Al$ = 224
_Old_ptr$ = 232
_Capacity$ = 240
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 2628 :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__270D62DC_xstring
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2629 :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 2630 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00029	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR _Capacity$[rbp]
  00030	48 ff c0	 inc	 rax
  00033	4c 8b c0	 mov	 r8, rax
  00036	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR _Old_ptr$[rbp]
  0003d	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR _Al$[rbp]
  00044	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
  00049	90		 npad	 1

; 2631 :     }

  0004a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00051	5f		 pop	 rdi
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0001a	48 83 c0 08	 add	 rax, 8
  0001e	48 8b c8	 mov	 rcx, rax
  00021	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
  00026	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0002d	5f		 pop	 rdi
  0002e	5d		 pop	 rbp
  0002f	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__270D62DC_xstring
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00026	5f		 pop	 rdi
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT

; 2247 :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__270D62DC_xstring
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2248 :         // start the lifetime of the array elements
; 2249 : #if _HAS_CXX20
; 2250 :         if (_STD is_constant_evaluated()) {
; 2251 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2252 :                 _Bx._Buf[_Idx] = value_type();
; 2253 :             }
; 2254 :         }
; 2255 : #endif // _HAS_CXX20
; 2256 :     }

  0001f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00026	5f		 pop	 rdi
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 192
this$ = 240
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT

; 2243 :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__270D62DC_xstring
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2244 :         return _Myres > _Small_string_capacity;

  0001f	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	48 83 78 20 0f	 cmp	 QWORD PTR [rax+32], 15
  0002b	76 0c		 jbe	 SHORT $LN3@Large_mode
  0002d	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv66[rbp], 1
  00037	eb 0a		 jmp	 SHORT $LN4@Large_mode
$LN3@Large_mode:
  00039	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv66[rbp], 0
$LN4@Large_mode:
  00043	0f b6 85 c0 00
	00 00		 movzx	 eax, BYTE PTR tv66[rbp]

; 2245 :     }

  0004a	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  00051	5f		 pop	 rdi
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 224
_Ptr$ = 232
_Count$ = 240
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 970  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00018	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__53DEE440_xmemory
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN4@deallocate:

; 971  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  00029	48 83 bd e8 00
	00 00 00	 cmp	 QWORD PTR _Ptr$[rbp], 0
  00031	75 0a		 jne	 SHORT $LN10@deallocate
  00033	48 83 bd f0 00
	00 00 00	 cmp	 QWORD PTR _Count$[rbp], 0
  0003b	75 02		 jne	 SHORT $LN8@deallocate
$LN10@deallocate:
  0003d	eb 6b		 jmp	 SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  00046	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0004b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00052	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00057	45 33 c9	 xor	 r9d, r9d
  0005a	41 b8 cb 03 00
	00		 mov	 r8d, 971		; 000003cbH
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GC@MFPFMMDA@C?3?2Program?5Files?2Microsoft?5Visu@
  00067	b9 02 00 00 00	 mov	 ecx, 2
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00072	83 f8 01	 cmp	 eax, 1
  00075	75 03		 jne	 SHORT $LN12@deallocate
  00077	cc		 int	 3
  00078	33 c0		 xor	 eax, eax
$LN12@deallocate:
  0007a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00083	41 b9 cb 03 00
	00		 mov	 r9d, 971		; 000003cbH
  00089	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1ME@HBHJKKLJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000a4	33 c0		 xor	 eax, eax
  000a6	85 c0		 test	 eax, eax
  000a8	75 95		 jne	 SHORT $LN7@deallocate
$LN9@deallocate:
  000aa	33 c0		 xor	 eax, eax
  000ac	85 c0		 test	 eax, eax
  000ae	0f 85 75 ff ff
	ff		 jne	 $LN4@deallocate

; 972  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 973  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000b4	48 8b 95 f0 00
	00 00		 mov	 rdx, QWORD PTR _Count$[rbp]
  000bb	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR _Ptr$[rbp]
  000c2	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 974  :     }

  000c7	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  000ce	5f		 pop	 rdi
  000cf	5d		 pop	 rbp
  000d0	c3		 ret	 0
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 224
_Right$ = 232
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 438  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__270D62DC_xstring
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             return _Primary_char_traits::assign(_Left, _Right);
; 442  :         }
; 443  : #endif // _HAS_CXX20
; 444  :         _Left = _Right;

  00024	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR _Left$[rbp]
  0002b	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR _Right$[rbp]
  00032	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00035	88 08		 mov	 BYTE PTR [rax], cl

; 445  :     }

  00037	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0003e	5f		 pop	 rdi
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\utility
;	COMDAT ??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 8
_Val$ = 256
_New_val$ = 264
??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__394B8783_utility
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00024	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR _Val$[rbp]
  0002b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002e	48 89 45 08	 mov	 QWORD PTR _Old_val$[rbp], rax

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  00032	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR _Val$[rbp]
  00039	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR _New_val$[rbp]
  00040	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00043	48 89 08	 mov	 QWORD PTR [rax], rcx

; 764  :     return _Old_val;

  00046	48 8b 45 08	 mov	 rax, QWORD PTR _Old_val$[rbp]

; 765  : }

  0004a	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00051	5f		 pop	 rdi
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Lock$ = 4
__$ArrayPad$ = 216
this$ = 256
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT

; 1229 :     void _Orphan_all_locked_v3() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00018	b9 0a 00 00 00	 mov	 ecx, 10
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00033	48 33 c5	 xor	 rax, rbp
  00036	48 89 85 d8 00
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__53DEE440_xmemory
  00044	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1230 :         _Lockit _Lock(_LOCK_DEBUG);

  00049	ba 03 00 00 00	 mov	 edx, 3
  0004e	48 8d 4d 04	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1231 :         _Orphan_all_unlocked_v3();

  00058	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0005f	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1232 :     }

  00064	48 8d 4d 04	 lea	 rcx, QWORD PTR _Lock$[rbp]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0006e	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcFrameData
  00079	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0007e	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00085	48 33 cd	 xor	 rcx, rbp
  00088	e8 00 00 00 00	 call	 __security_check_cookie
  0008d	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00094	5f		 pop	 rdi
  00095	5d		 pop	 rbp
  00096	c3		 ret	 0
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Pnext$1 = 8
$T2 = 228
this$ = 288
?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT

; 1369 : _CONSTEXPR20 void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__53DEE440_xmemory
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1370 :     if (!_Myproxy) { // no proxy, already done

  0001f	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0002a	75 02		 jne	 SHORT $LN5@Orphan_all

; 1371 :         return;

  0002c	eb 4e		 jmp	 SHORT $LN1@Orphan_all
$LN5@Orphan_all:

; 1372 :     }
; 1373 : 
; 1374 :     // proxy allocated, drain it
; 1375 :     for (auto _Pnext = _STD exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {

  0002e	48 c7 85 e4 00
	00 00 00 00 00
	00		 mov	 QWORD PTR $T2[rbp], 0
  00039	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00043	48 83 c0 08	 add	 rax, 8
  00047	48 8d 95 e4 00
	00 00		 lea	 rdx, QWORD PTR $T2[rbp]
  0004e	48 8b c8	 mov	 rcx, rax
  00051	e8 00 00 00 00	 call	 ??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
  00056	48 89 45 08	 mov	 QWORD PTR _Pnext$1[rbp], rax
  0005a	eb 0c		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:
  0005c	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$1[rbp]
  00060	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00064	48 89 45 08	 mov	 QWORD PTR _Pnext$1[rbp], rax
$LN4@Orphan_all:
  00068	48 83 7d 08 00	 cmp	 QWORD PTR _Pnext$1[rbp], 0
  0006d	74 0d		 je	 SHORT $LN1@Orphan_all

; 1376 :         _Pnext->_Myproxy = nullptr;

  0006f	48 8b 45 08	 mov	 rax, QWORD PTR _Pnext$1[rbp]
  00073	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1377 :     }

  0007a	eb e0		 jmp	 SHORT $LN2@Orphan_all
$LN1@Orphan_all:

; 1378 : }

  0007c	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  00083	5f		 pop	 rdi
  00084	5d		 pop	 rbp
  00085	c3		 ret	 0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?_Orphan_all@_Container_base12@std@@QEAAXXZ PROC	; std::_Container_base12::_Orphan_all, COMDAT

; 1380 : _CONSTEXPR20 void _Container_base12::_Orphan_all() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__53DEE440_xmemory
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1381 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1382 : #if _HAS_CXX20
; 1383 :     if (_STD is_constant_evaluated()) {
; 1384 :         _Orphan_all_unlocked_v3();
; 1385 :     } else
; 1386 : #endif // _HAS_CXX20
; 1387 :     {
; 1388 :         _Orphan_all_locked_v3();

  0001f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_locked_v3

; 1389 :     }
; 1390 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1391 : }

  0002b	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00032	5f		 pop	 rdi
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QEAAXXZ ENDP	; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.38.33130\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Ptr_user$ = 8
_Ptr_container$ = 40
_Min_back_shift$ = 72
_Back_shift$ = 104
_Ptr$ = 352
_Bytes$ = 360
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 154  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  00013	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__53DEE440_xmemory
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 155  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 156  :     _Bytes += _Non_user_size;

  00024	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR _Bytes$[rbp]
  0002b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002e	48 83 c0 2f	 add	 rax, 47			; 0000002fH
  00032	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR _Bytes$[rbp]
  00039	48 89 01	 mov	 QWORD PTR [rcx], rax

; 157  : 
; 158  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

  0003c	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR _Ptr$[rbp]
  00043	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00046	48 89 45 08	 mov	 QWORD PTR _Ptr_user$[rbp], rax

; 159  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0004a	b8 08 00 00 00	 mov	 eax, 8
  0004f	48 6b c0 ff	 imul	 rax, rax, -1
  00053	48 8b 4d 08	 mov	 rcx, QWORD PTR _Ptr_user$[rbp]
  00057	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0005b	48 89 45 28	 mov	 QWORD PTR _Ptr_container$[rbp], rax
$LN4@Adjust_man:

; 160  : 
; 161  :     // If the following asserts, it likely means that we are performing
; 162  :     // an aligned delete on memory coming from an unaligned allocation.
; 163  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  0005f	b8 08 00 00 00	 mov	 eax, 8
  00064	48 6b c0 fe	 imul	 rax, rax, -2
  00068	48 8b 4d 08	 mov	 rcx, QWORD PTR _Ptr_user$[rbp]
  0006c	48 ba fa fa fa
	fa fa fa fa fa	 mov	 rdx, -361700864190383366 ; fafafafafafafafaH
  00076	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  0007a	75 02		 jne	 SHORT $LN14@Adjust_man
  0007c	eb 77		 jmp	 SHORT $LN15@Adjust_man
$LN14@Adjust_man:
$LN7@Adjust_man:
  0007e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  00084	83 c0 09	 add	 eax, 9
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
  0008e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  0009a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0009f	45 33 c9	 xor	 r9d, r9d
  000a2	44 8b c0	 mov	 r8d, eax
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GC@MFPFMMDA@C?3?2Program?5Files?2Microsoft?5Visu@
  000ac	b9 02 00 00 00	 mov	 ecx, 2
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  000b7	83 f8 01	 cmp	 eax, 1
  000ba	75 03		 jne	 SHORT $LN19@Adjust_man
  000bc	cc		 int	 3
  000bd	33 c0		 xor	 eax, eax
$LN19@Adjust_man:
  000bf	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  000c5	83 c0 09	 add	 eax, 9
  000c8	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000d1	44 8b c8	 mov	 r9d, eax
  000d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1ME@HBHJKKLJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000ef	33 c0		 xor	 eax, eax
  000f1	85 c0		 test	 eax, eax
  000f3	75 89		 jne	 SHORT $LN7@Adjust_man
$LN15@Adjust_man:
  000f5	33 c0		 xor	 eax, eax
  000f7	85 c0		 test	 eax, eax
  000f9	0f 85 60 ff ff
	ff		 jne	 $LN4@Adjust_man

; 164  : 
; 165  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 166  :     // in range [_Min_back_shift, _Non_user_size]
; 167  : #ifdef _DEBUG
; 168  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

  000ff	48 c7 45 48 10
	00 00 00	 mov	 QWORD PTR _Min_back_shift$[rbp], 16

; 169  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 170  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 171  : #endif // ^^^ !defined(_DEBUG) ^^^
; 172  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00107	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR _Ptr$[rbp]
  0010e	48 8b 4d 28	 mov	 rcx, QWORD PTR _Ptr_container$[rbp]
  00112	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00115	48 2b c1	 sub	 rax, rcx
  00118	48 89 45 68	 mov	 QWORD PTR _Back_shift$[rbp], rax
$LN10@Adjust_man:

; 173  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0011c	48 83 7d 68 10	 cmp	 QWORD PTR _Back_shift$[rbp], 16
  00121	72 09		 jb	 SHORT $LN16@Adjust_man
  00123	48 83 7d 68 2f	 cmp	 QWORD PTR _Back_shift$[rbp], 47 ; 0000002fH
  00128	77 02		 ja	 SHORT $LN16@Adjust_man
  0012a	eb 77		 jmp	 SHORT $LN17@Adjust_man
$LN16@Adjust_man:
$LN13@Adjust_man:
  0012c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  00132	83 c0 13	 add	 eax, 19
  00135	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
  0013c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00141	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  00148	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0014d	45 33 c9	 xor	 r9d, r9d
  00150	44 8b c0	 mov	 r8d, eax
  00153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GC@MFPFMMDA@C?3?2Program?5Files?2Microsoft?5Visu@
  0015a	b9 02 00 00 00	 mov	 ecx, 2
  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  00165	83 f8 01	 cmp	 eax, 1
  00168	75 03		 jne	 SHORT $LN20@Adjust_man
  0016a	cc		 int	 3
  0016b	33 c0		 xor	 eax, eax
$LN20@Adjust_man:
  0016d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
  00173	83 c0 13	 add	 eax, 19
  00176	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0017f	44 8b c8	 mov	 r9d, eax
  00182	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1ME@HBHJKKLJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00189	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  00190	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  0019d	33 c0		 xor	 eax, eax
  0019f	85 c0		 test	 eax, eax
  001a1	75 89		 jne	 SHORT $LN13@Adjust_man
$LN17@Adjust_man:
  001a3	33 c0		 xor	 eax, eax
  001a5	85 c0		 test	 eax, eax
  001a7	0f 85 6f ff ff
	ff		 jne	 $LN10@Adjust_man

; 174  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001ad	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR _Ptr$[rbp]
  001b4	48 8b 4d 28	 mov	 rcx, QWORD PTR _Ptr_container$[rbp]
  001b8	48 89 08	 mov	 QWORD PTR [rax], rcx

; 175  : }

  001bb	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  001c2	5f		 pop	 rdi
  001c3	5d		 pop	 rbp
  001c4	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File \\Mac\Home\Documents\fit\kpo\kpo1\kpo1\isCorrect.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_K@Z
_TEXT	SEGMENT
__formal$ = 224
__formal$ = 232
?__empty_global_delete@@YAXPEAX_K@Z PROC		; __empty_global_delete, COMDAT

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__FFA5C47D_isCorrect@cpp
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0002b	5f		 pop	 rdi
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?__empty_global_delete@@YAXPEAX_K@Z ENDP		; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File \\Mac\Home\Documents\fit\kpo\kpo1\kpo1\isCorrect.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX@Z
_TEXT	SEGMENT
__formal$ = 224
?__empty_global_delete@@YAXPEAX@Z PROC			; __empty_global_delete, COMDAT

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__FFA5C47D_isCorrect@cpp
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00026	5f		 pop	 rdi
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
?__empty_global_delete@@YAXPEAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
